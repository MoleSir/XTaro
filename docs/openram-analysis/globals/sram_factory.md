# `sram_factory`

在 sram_factor.py 中定义的 `sram_`。这个只需要导入 `OPTS` 即可。其中描述了类：`sram_factory`：

````python
class sram_factory:
    """
    This is a factory pattern to create modules for usage in an SRAM.
    Since GDSII has a flat namespace, it requires modules to have unique
    names if their layout differs. This module ensures that any module
    with different layouts will have different names. It also ensures that
    identical layouts will share the same name to reduce file size and promote
    hierarchical sharing.
    """
   	...
````

OpenRAM 中所有关于模型对象的实例化工作由这个类完成。



## 字段

```python
def __init__(self):
    # A dictionary of modules indexed by module type
    self.modules = {}
    # These are the indices to append to name to make unique object names
    self.module_indices = {}
    # A dictionary of instance lists indexed by module type
    self.objects = {}
```

- `modules`：保存模块的字典。字：模块名称字符串，值：模块类（就是模块的类，不是类的实例化）
- `modules`：保存某个模块已经被命名了几个实例化对象。字：模块名称字符串，值：模块实例化数量；
- `objects`：保存由工厂类创建的所有对象以及其创建时传入的构造函数参数；



## `create` 函数

````python
    def create(self, module_type, module_name=None, **kwargs):
        """
        A generic function to create a module with a given module_type.
        The args are passed directly to the module constructor.
        """
````

其中的参数有：

- `module_type`：需要创建的模块名称，以字符串形式给出，例如 `and2_dec`；
- `module_name`：需要创建的模块实例化对象的名称 ，注意这个是利用模块类实例化出的对象的名称；
- `kwargs`：传递给模块构造函数的参数。

### 获得模块名称

````python
tech_module_type, tm_overridden = self.get_techmodule_type(module_type)
user_module_type, um_overridden = self.get_usermodule_type(module_type)
# overridden user modules have priority
if um_overridden:
    real_module_type = user_module_type
# then overridden tech modules
elif tm_overridden:
    real_module_type = tech_module_type
# if nothing else works use the name generated by get_usermodule_type()
else:
    real_module_type = user_module_type
````

都是为了得到模块类的最终名称，因为有可能用户需要定制自己的类对象。但不要紧，最后会把类对象名称保存在 `real_module_type` 中。

### 获得模型类

````python
# Either retrieve the already loaded module or load it
try:
    # Load a cached version from previous usage
    mod = self.modules[real_module_type]
except KeyError:
    try:
        # Dynamically load the module
        if real_module_type == "contact":
            c  = importlib.import_module("openram.base.contact")
        elif real_module_type == "sram":
            c = importlib.import_module("openram.sram")
        else:
            c  = importlib.import_module("openram.modules."+real_module_type)
    except ModuleNotFoundError:
        # Check if it is a technology specific module
        c  = importlib.import_module("openram.custom."+real_module_type)

    mod = getattr(c, real_module_type)

    self.modules[real_module_type] = mod
    self.module_indices[real_module_type] = 0
    self.objects[real_module_type] = []
````

1. 先尝试从 `self.modules` 字典中查找 `real_module_type` 这个值，如果存在，说明这个类型的模型已经有创建过，直接获取保存在 `mod` 中；
2. 如果查找失败，就需要从 `openram.module` 加载，总之最后也得到了模型类 `mod`，说明这个模块还没被创建；
3. 如果模型没有被创建，那么更新工厂的三个字段：
   - `self.modules[real_module_type] = mod`：保存这个模型类到字典中，方便下一次直接获取；
   - `self.module_indices[real_module_type] = 0`：因为这个模型刚刚被加入，所以其实例化次数为 0；
   - `self.objects[real_module_type] = []`：因为这个模型刚刚被加入，其实例化对象为空列表；

### 判断是否存在同样的对象

````python
# Either retreive a previous object or create a new one
for obj in self.objects[real_module_type]:
    (obj_kwargs, obj_item) = obj
    # Must have the same dictionary exactly (conservative)
    if obj_kwargs == kwargs:
        return obj_item
````

1. 遍历 `self.objects[real_module_type]` 中的每一项；
2. 将每一项解释为 一个参数列表字典 `obj_kwargs` 与实例化对象 `obj_item`；
3. 如果 `obj_kwargs` 与本次创建传入的参数列表 `kwargs` 相同，直接返回 `obj_item` 不再创建（享元模式？？）；

### 确定模型对象名称

````python
# If no prefered module name is provided, we generate one.
if not module_name:
    if len(self.objects[real_module_type]) > 0:
        # Create a unique name and increment the index
        module_name = "{0}_{1}".format(real_module_type,
                                       self.module_indices[real_module_type])
        self.module_indices[real_module_type] += 1
    else:
        module_name = real_module_type
else:
    if self.is_duplicate_name(module_name):
        raise ValueError("Modules with duplicate name are not allowed."
                         " '{}'".format(module_name))
````

如果调用 `create` 时没有给定实例化对象的名称，就需要自动生成一个：

1. 判断当前模型是否有自动命名实例化对象：`if len(self.objects[real_module_type]) > 0`
2. 如果有就使用下一个索引加上模块名称命名，例如 `and2_dec_1`，并且增加实例化数量 `self.module_indices[real_module_type] += 1`；
3. 如果没有就说明这是第一个，直接用模块名命名；

如果给定了，判断一下这个名称是不是有重复，方法是遍历所有 `objects` 中的对象进行比较。

### 实例化对象

````python
obj = mod(name=module_name, **kwargs)
self.objects[real_module_type].append((kwargs, obj))
return obj
````

1. 使用 `mod` 的构造函数创建对象 `obj`，并且传入参数：`(name=module_name, **kwargs)`；
2. 将实例化对象与创建时的构造函数参数列表添加到 `objects[real_module_type]` 中。这是一个列表，其中的每个元素是一个元组，元组第一个元素是构造函数参数列表，第二个元素是对应的实例化对象。这也是为什么 [判断重复对象](###判断是否存在同样的对象) 时会使用那样奇怪的方法。
3. 返回 `obj`。



